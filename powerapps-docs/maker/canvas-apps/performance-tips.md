---
title: Оптимизация производительности приложений на основе холста | Документация Майкрософт
description: Следуйте рекомендациям этого раздела, чтобы повысить производительность приложений на основе холста, созданных в PowerApps.
author: yingchin
manager: kvivek
ms.service: powerapps
ms.topic: conceptual
ms.custom: canvas
ms.reviewer: tapanm
ms.date: 06/17/2019
ms.author: yingchin
search.audienceType:
- maker
search.app:
- PowerApps
ms.openlocfilehash: 9943678815b53df048ad197e3cdcbd56f4070fa3
ms.sourcegitcommit: 7dae19a44247ef6aad4c718fdc7c68d298b0a1f3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "71995784"
---
# <a name="optimize-canvas-app-performance-in-powerapps"></a>Оптимизация производительности приложений на основе холста в PowerApps
Корпорация Майкрософт прилагает все усилия, чтобы повысить производительность всех приложений, работающих на платформе PowerApps. Следуйте рекомендациям этого раздела, чтобы повысить производительность созданных приложений.

Когда пользователь открывает приложение, перед показом любого пользовательского интерфейса, он проходит такие этапы выполнения. 
1. **Проверка подлинности пользователя**. Инструктирование пользователя, если он никогда ранее не открывал приложение, как выполнить вход с учетными данными для любых подключений, необходимых для приложения. Если тот же пользователь снова откроет приложение, ему могут быть выданы инструкции еще раз, в зависимости от политик безопасности организации. 
2. **Получение метаданных**. Извлечение метаданных таких, как версия платформы PowerApps, на которой запускается приложение, и источники, из которых необходимо извлекать данные. 
3. **Инициализация приложения**. Выполнение всех задач, указанных в свойстве **OnStart**. 
4. **Отображения экранов**. Отображение первого экрана с элементами управления, которых приложение заполняет данными. Если пользователь открывает другие экраны, приложение отображает их, используя тот же процесс.  

## <a name="limit-data-connections"></a>Ограничение подключений к данным 
**Не подключайте более 30 источников данных из одного приложения**. Приложения подсказывают новым пользователям выполнить вход в каждый соединитель, поэтому каждый дополнительный соединитель увеличивает время, необходимое для запуска приложения. Когда приложение запрашивает данные из этого источника, по мере запуска приложения каждый соединитель требует ресурсы процессора, памяти и пропускной способности сети. 

Можно быстро оценить производительность приложения, включив инструменты разработчика в [Microsoft Edge](https://docs.microsoft.com/microsoft-edge/devtools-guide/network) или [Google Chrome](https://developers.google.com/web/tools/chrome-devtools/network-performance/) во время запуска приложения. Приложение может потребовать больше 15 секунд для возврата данных, если оно часто запрашивает данные из более чем 30 источников данных, таких как Common Data Service, Azure SQL, SharePoint и Excel в OneDrive.  

## <a name="limit-the-number-of-controls"></a>Ограничение количества элементов управления 
**Не добавляйте более 500 элементов управления в одно приложение**. PowerApps создает HTML DOM для отрисовки каждого элемента управления. Чем больше элементов управления вы добавляете, тем больше требуется времени PowerApps. 

Если использовать коллекцию вместо отдельных элементов управления, в некоторых случаях вы можете добиться того же результата и быстрее запустить приложение. Кроме того, может потребоваться уменьшить количество типов элементов управления на одном экране. Некоторые элементы управления (такие как средство просмотра PDF, таблица данных и поле со списком) загружают большие сценарии выполнения и занимают больше времени для отрисовки. 

## <a name="optimize-the-onstart-function"></a>Оптимизация функции OnStart
Используйте функцию [**ClearCollect** ](functions/function-clear-collect-clearcollect.md) для локального кэширования данных, если она не изменяется во время сеанса пользователя. Кроме того, используйте функцию [**Concurrent**](functions/function-concurrent.md) для одновременной загрузки источников данных.

Используйте функцию **Concurrent**, чтобы сократить время, в течение которого приложение должно загружать данные наполовину, как иллюстрирует [этот раздел справки](functions/function-concurrent.md).

Без функции **Concurrent** эта формула загружает каждую из четырех таблиц по одному за раз:

```
ClearCollect( Product, '[SalesLT].[Product]' );
ClearCollect( Customer, '[SalesLT].[Customer]' );
ClearCollect( SalesOrderDetail, '[SalesLT].[SalesOrderDetail]' );
ClearCollect( SalesOrderHeader, '[SalesLT].[SalesOrderHeader]' )
```

Вы можете подтвердить это поведение в средствах для разработчиков своего веб-браузера.

![Серийная функция ClearCollect](./media/performance-tips/perfconcurrent1.png)
    
Можно включить ту же формулу в функцию **Concurrent**, чтобы сократить общее время, необходимое для работы.

```
Concurrent( 
    ClearCollect( Product, '[SalesLT].[Product]' ),
    ClearCollect( Customer, '[SalesLT].[Customer]' ),
    ClearCollect( SalesOrderDetail, '[SalesLT].[SalesOrderDetail]' ),
    ClearCollect( SalesOrderHeader, '[SalesLT].[SalesOrderHeader]' ))
```

С помощью этого изменения приложение извлекает таблицы в параллельном режиме. 

![Параллельная Клеарколлект](./media/performance-tips/perfconcurrent2.png)  

## <a name="cache-lookup-data"></a>Данные поиска кэша
Используйте функцию **Set** для кэширования данных из просмотра локальных таблиц, чтобы избежать многократного получения данных из источника. Этот метод оптимизирует производительность, если данные с большей вероятностью не изменятся во время сеанса. Как и в этом примере, данные извлекаются из источника один раз, а после этого ссылаются локально, пока пользователь не закрывает приложение. 

```
Set(CustomerOrder, Lookup(Order, id = “123-45-6789”));
Set(CustomerName, CustomerOrder.Name);
Set(CustomerAddress, CustomerOrder.Address);
Set(CustomerEmail, CustomerOrder.Email);
Set(CustomerPhone, CustomerOrder.Phone);
```

Контактные данные изменяются редко, как и значения по умолчанию и сведения о пользователе. Таким образом, вы можете использовать этот метод с функциями **Defaults** и **User**. 

## <a name="avoid-controls-dependency-between-screens"></a>Недопущение зависимостей элементов управления между появлением экранов
Для повышения производительности экраны приложения загружаются в память только по мере необходимости. Такая оптимизация может быть невозможна, если, например, загружается экран 1 и одна из его формул использует свойство элемента управления из экрана 2. Теперь необходимо загрузить экран 2 для выполнения зависимости перед отображением экрана 1. Представьте, что экран 2 имеет зависимость от экрана 3, которая имеет другую зависимость от экрана 4 и т. д. Эта цепочка зависимостей может привести к загрузке множества экранов.

По этой причине не следует использовать зависимости формулы между экранами. В некоторых случаях для обмена информацией между экранами можно использовать глобальную переменную или коллекцию.

Существует исключение. В предыдущем примере Представьте, что единственный способ отображения экрана 1 — переход с экрана 2. Затем экран 2 уже был загружен в память при загрузке экрана 1. Для выполнения зависимости на экране 2 не требуется никаких дополнительных операций, поэтому производительность не снижается.

## <a name="use-delegation"></a>Использование делегирования
По возможности используйте функции, которые делегируют обработку данных в источник данных вместо того, чтобы получать данные на локальное устройство для обработки. Если приложение должно обрабатывать данные локально, для выполнения операции потребуется гораздо больше вычислительной мощности, памяти и пропускной способности сети, особенно если набор данных является большим.

Как показано в [этом списке](delegation-list.md), разные источники данных поддерживают делегирование из разных функций.

![Использование делегирования](./media/performance-tips/perfdelegation1.png)

Например, SharePoint перечисляет поддержку делегирования из функции [**Filter**](functions/function-filter-lookup.md), вместо функции [**Search**](functions/function-filter-lookup.md). Поэтому следует использовать **Filter** вместо **Search** для поиска элементов в коллекции, если список SharePoint содержит более чем 500 элементов. Дополнительные советы см. в разделе [Working with large SharePoint lists in PowerApps](https://powerapps.microsoft.com/blog/powerapps-now-supports-working-with-more-than-256-items-in-sharepoint-lists/) (Работа с большими списками SharePoint в PowerApps) (запись блога). 

## <a name="use-delayed-load"></a>Используйте отложенную загрузку
Включите [экспериментальную функцию](working-with-experimental.md) для отложенной загрузки, если ваше приложение имеет более 10 экранов и множество элементов управления, которые находятся на нескольких экранах и напрямую связаны с источником данных, и не имеют правил. Если вы создаете этот тип приложения и не включаете эту функцию, производительность приложения может снизится, так как элементы управления должны заполняться на всех экранах, даже на экранах, которые не открыты. Кроме того, все экраны приложения должны обновляться всякий раз, когда изменяется источник данных, например, когда пользователь добавляет запись.

## <a name="working-with-large-data-sets"></a>Работа с большими наборами данных
Используйте источники данных и формулы, которые можно делегировать, чтобы ваши приложения работали хорошо, а пользователи могли получить доступ ко всей необходимой им информации и избежать ограничения в 2000 строк данных для неделегированных запросов. Для записи данных столбцов, по которым пользователи могут искать, фильтровать или сортировать данные, эти индексы разрабатываются так же, как описано в документации для [SQL Server](https://docs.microsoft.com/sql/relational-databases/sql-server-index-design-guide?view=sql-server-2017) и [SharePoint](https://support.office.com/article/Add-an-index-to-a-SharePoint-column-f3f00554-b7dc-44d1-a2ed-d477eac463b0).  

## <a name="republish-apps-regularly"></a>Регулярная повторная публикация приложений
[Опубликуйте свои приложения повторно](https://powerapps.microsoft.com/blog/republish-your-apps-to-get-performance-improvements-and-additional-features/) (запись блога), чтобы получить повышение производительности и дополнительные функции от платформы PowerApps.

## <a name="avoid-repeating-the-same-formula-in-multiple-places"></a>Старайтесь не повторять одну и ту же формулу в нескольких местах
Если несколько свойств выполняют одну и ту же формулу (особенно если они сложны), попробуйте установить их один раз, а затем сослаться на выходные данные первого свойства в последующих. Например, не устанавливайте для свойства **DisplayMode** элементов управления A, B, C, D и E одну и ту же сложную формулу. Вместо этого задайте для свойства **DisplayMode** комплексную формулу, задайте для свойства B **DisplayMode** результат свойства **DisplayMode** и т. д. для C, D и E.

## <a name="enable-delayoutput-on-all-text-input-controls"></a>Включение Делайаутпут для всех элементов управления вводом текста
Если имеется несколько формул или правил, которые ссылаются на значение элемента управления **вводом текста** , установите для свойства **делайедаутпут** этого элемента управления значение true. Свойство **Text** этого элемента управления будет обновляться только после того, как нажатия клавиш, введенные в ходе быстрой успешной работы, были прекращены. Формулы или правила не выполняются столько раз, и производительность приложения повысится.

## <a name="avoid-using-formupdates-in-rules-and-formulas"></a>Избегайте использования формы. обновления в правилах и формулах
Если вы ссылаетесь на пользовательское значение в правиле или формуле с помощью **формы. обновляет** переменную, она выполняет перебор всех карт данных формы и создает запись каждый раз. Чтобы сделать приложение более эффективным, сослаться на значение непосредственно из карточки данных или из значения элемента управления.

## <a name="next-steps"></a>Дальнейшие действия
Ознакомьтесь с [стандартами кодирования](https://aka.ms/powerappscanvasguidelines) для максимизации производительности приложений и упрощения обслуживания приложений.
