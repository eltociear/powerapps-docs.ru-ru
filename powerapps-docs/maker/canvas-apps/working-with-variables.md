---
title: Общие сведения о переменных в приложениях на основе холста | Документы Майкрософт
description: Справочные сведения о работе с состояниями, контекстными переменными и коллекциями в приложениях на основе холста
author: gregli-msft
manager: kvivek
ms.service: powerapps
ms.topic: conceptual
ms.custom: canvas
ms.reviewer: anneta
ms.date: 02/28/2019
ms.author: gregli
search.audienceType:
- maker
search.app:
- PowerApps
ms.openlocfilehash: 6f46dcdf300c91be9fbc2f39e6b2a5418a4b82de
ms.sourcegitcommit: 4042388fa5e7ef50bc59f9e35df330613fea29ae
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61559318"
---
# <a name="understand-canvas-app-variables-in-powerapps"></a>Общие сведения о переменных в приложениях на основе холста в PowerApps

Если вы использовали другое средство программирования, например Visual Basic или JavaScript, вас может возникнуть вопрос: **Где находятся переменные?** PowerApps немного отличается и требует иного подхода. А не обращаться к переменной, при построении приложения на основе холста, задайте себе. **Что бы сделать в Excel?**

Возможно, в других средствах вы явно выполняли вычисления и хранили результаты в переменной. Однако в PowerApps и Excel формулы пересчитываются автоматически при изменении входных данных, поэтому обычно не требуется создавать и обновлять переменные. Применяя такой подход по мере возможности, можно легко создавать и обслуживать приложения, полностью понимая принцип их работы.

В некоторых случаях в PowerApps необходимо использовать переменные, которые расширяют модель Excel, добавляя в нее [формулы поведения](working-with-formulas-in-depth.md). Эти формулы, например, выполняются, когда пользователь нажимает кнопку. В формуле поведения зачастую удобно задать переменную, которую можно использовать в других формулах.

Как правило, использовать переменные нежелательно. Однако иногда только с их помощью можно обеспечить желаемые возможности. Переменные создаются и неявно типизированный, когда они присутствуют в функции, устанавливающие их значения. 

## <a name="translate-excel-into-powerapps"></a>Реализация подхода Excel в PowerApps

### <a name="excel"></a>Excel

Давайте посмотрим, как работает Excel. Ячейка может содержать значение, например число, строку или формулу, в которой используются значения других ячеек. После того как пользователь вводит другое значение в ячейку, Excel автоматически пересчитывает все формулы, которые зависят от нового значения. При этом для обеспечения такого поведения не нужно ничего программировать.

В следующем примере ячейки **A3** задана формула **A1 + A2**. Если **A1** или **A2** изменения, **A3** автоматически пересчитывает в соответствии с изменениями. Это поведение не требует кода за пределами сама формула.

![Анимация повторное вычисление суммы двух чисел в Excel](media/working-with-variables/excel-recalc.gif)

В Excel нет переменных. Значение ячейки, содержащей формулу, изменяется в зависимости от входных данных, но при этом нет возможности запомнить результат формулы и сохранить его в ячейке или в любом другом месте. При изменении значения ячейки может измениться вся таблица, а все ранее вычисляемые значения будут утрачены. Пользователь Excel может копировать и вставлять ячейки, но это нужно делать вручную. С помощью формул выполнить такую операцию невозможно.

### <a name="powerapps"></a>PowerApps

Поведение приложений, создаваемых в PowerApps, во многом напоминает поведение Excel. Вместо обновления ячеек можно добавить элементы управления в любом месте на экране и присвоить им имена, чтобы их можно было использовать в формулах.

Например, можно воспроизвести поведение Excel в приложении, добавив **[метка](controls/control-text-box.md)** управления с именем **Label1**и два **[вводатекста](controls/control-text-input.md)** с именами **TextInput1** и **TextInput2**. Если затем задать **[текст](controls/properties-core.md)** свойство **Label1** для **TextInput1 + TextInput2**, он всегда будет отображаться сумма независимо от значений находятся в **TextInput1** и **TextInput2** автоматически.

![Вычисление суммы двух чисел в PowerApps](media/working-with-variables/recalc1.png)

Обратите внимание, что **Label1** выборе элемента управления, показывающий его **[текст](controls/properties-core.md)** формулы в строке формул в верхней части экрана. В данном случае она выглядит таким образом: **TextInput1 + TextInput2**. Эта формула создает между этими элементами управления такую же зависимость, как между ячейками в книге Excel.  Изменим значение **TextInput1**:

![Анимация для расчета суммы двух чисел в PowerApps](media/working-with-variables/recalc2.gif)

Формула для **Label1** автоматически пересчитывается, отображается новое значение.

Чтобы в PowerApps определить не только основное значение элемента управления, но и его свойства, например форматирование, можно воспользоваться формулами. В следующем примере формула для свойства **[Color](controls/properties-color-border.md)** метки обеспечит автоматическое отображение отрицательных значений красным цветом. Функция **[If](functions/function-if.md)** очень похожа на ту, которая используется в Excel.

`If( Value(Label1.Text) < 0, Red, Black )`

![Анимация условного форматирования](media/working-with-variables/recalc-color.gif)

Формулы можно использовать в самых разнообразных сценариях.

* Используя GPS-модуль устройства, элемент управления картой может отобразить ваше текущее расположение с помощью формулы, использующей значения **Location.Latitude** и **Location.Longitude**.  При перемещении карта будет автоматически отслеживать расположение.
* Другие пользователи могут обновлять [источники данных](working-with-data-sources.md).  Например, другие участники группы могут обновлять элементы в списке SharePoint.  При обновлении источника данных все зависимые формулы автоматически пересчитываются, в результате чего отображаются обновленные данные. Дополнив этот пример, можно задать коллекцию свойства **[Items](controls/properties-core.md)** в формуле **Filter( SharePointList )** , что обеспечит автоматическое отображение заново отфильтрованного набора [записей](working-with-tables.md#records).

### <a name="benefits"></a>Преимущества

Использование формул для создания приложений дает множество преимуществ.

* Если вы умеете работать с Excel, вы умеете работать с PowerApps. Модель и язык формул у них одинаковы.
* Если вы использовали другие средства программирования, представьте себе, сколько бы вам пришлось написать кода, чтобы обеспечить вычисления, приведенные в этих примерах.  В Visual Basic необходимо написать обработчик событий для события изменения в каждом текстовом поле.  Код, необходимый для выполнения вычисления в каждом из них, избыточен и может не синхронизироваться, или же вам придется написать общие подпрограммы.  В PowerApps все это можно сделать с помощью единственной формулы в одну строку.
* Чтобы понять, где **Label1**берется текст, вы знаете, где искать: формулу в **[текст](controls/properties-core.md)** свойство.  Повлиять на текст данного элемента управления другими способами невозможно.  В традиционных средствах программирования любые подпрограммы и обработчики событий могут изменить значение метки из любого места в программе.  Из-за этого иногда сложно отследить, где и когда была изменена переменная.
* Изменив положение ползунка, пользователь может передумать и вернуть его в исходное положение.  В результате как бы ничего не происходит: приложение отображает такие же значения элемента управления, как и раньше.  Все это происходит без каких-либо последствий, так что можно смело экспериментировать и пробовать разные варианты, что в Excel попросту невозможно.  

Как правило, если желаемого эффекта можно добиться с помощью формулы, лучше использовать именно ее. Обработчик формул PowerApps сделает все автоматически.  

## <a name="know-when-to-use-variables"></a>Ситуации, в которых имеет смысл использовать переменные

Давайте изменим наш простой сумматор так, чтобы он функционировал по принципу старинного арифмометра, используя нарастающий итог. При нажатии кнопки **Добавить** число добавляется к нарастающему итогу. При нажатии кнопки **Очистить** нарастающий итог обнуляется.

| Отображение | Описание |
|----|----|
| <style> img {Максимальная ширина: none} </style> ![приложения с помощью текстового ввода элемента управления, метки и две кнопки](media/working-with-variables/button-changes-state-1.png) | При запуске приложения, нарастающий итог равно 0.<br><br>Красная точка представляет пальцем пользователя в поле ввода текста, где пользователь вводит **77**. |
| ![77 содержит элемент управления для ввода текста и нажатии кнопки Add](media/working-with-variables/button-changes-state-2.png) | Пользователь выбирает **добавить** кнопки. |
| ![Общее значение составляет 77 и к нему добавляется другой 77](media/working-with-variables/button-changes-state-3.png) | 77 добавляется нарастающий итог.<br><br>Пользователь выбирает **добавить** еще раз. |
| ![Сумма — 154, прежде чем оно очищается.](media/working-with-variables/button-changes-state-4.png) | нарастающий итог, приводит к 154 снова добавляется 77.<br><br>Пользователь выбирает **Очистить** кнопки. |
| ![Общее очищается.](media/working-with-variables/button-changes-state-5.png) | Нарастающий итог обнуляется. |

Наш арифмометр использует то, чего нет в Excel: кнопки. В этом приложении для вычисления нарастающих итогов нельзя использовать только формулы, поскольку их значение зависит от ряда действий, которые выполняет пользователь. Вместо этого нарастающий итог записывается и обновляется вручную. Большинство средств программирования сохраняет эти сведения в *переменной*.

Иногда, чтобы приложения вели себя необходимым образом, требуется использовать переменные.  Однако такой подход применим с некоторыми оговорками.

* Нарастающий итог необходимо обновлять вручную. При автоматическом пересчете эта операция не выполняется.
* Нарастающий итог больше нельзя рассчитать на основе значений других элементов управления. Он зависит от того, сколько раз пользователь нажимает кнопку **Добавить** и какое значение при этом содержится в элементе управления текстовым вводом на момент ее нажатия. Ввел ли пользователь 77 и нажал **Добавить** дважды или же указал 24 и 130 в качестве слагаемых? После того как итог станет равным 154, определить разницу невозможно.
* Итог может изменяться по разным причинам. В этом примере к его изменению может приводить нажатие кнопок **Добавить** и **Очистить**. Как определить, какая кнопка вызывает проблему, если приложение не работает должным образом?

## <a name="use-a-global-variable"></a>Использовать глобальную переменную

Чтобы создать арифмометр, нам понадобится переменная для хранения нарастающего итога. Простейшие переменные в PowerApps — это *глобальные переменные*.  

Принцип их действия заключается в следующем:

* Значение глобальной переменной задается с помощью функции **[Set](functions/function-set.md)** .  **Set( MyVar, 1 )** задает для глобальной переменной **MyVar** значение **1**.
* Используйте эту глобальную переменную, ссылаясь на ее имя в функции **Set**.  В этом случае **MyVar** возвращает значение **1**.
* В глобальных переменных может храниться любое значение, в том числе строки, числа, записи и [таблицы](working-with-tables.md).

Перестроим наш арифмометр, воспользовавшись глобальными переменными.

1. Добавьте элемент управления текстовым вводом с именем **TextInput1** и две кнопки с именами **Button1** и **Button2**.

2. Задайте для свойства **[Text](controls/properties-core.md)** элемента управления **Button1** значение **"Add"** , а для свойства **Text** элемента управления **Button2** — значение **"Clear"** .

3. Чтобы нарастающий итог обновлялся, когда пользователь нажимает кнопку **Добавить**, задайте следующую формулу в качестве значения свойства **[OnSelect](controls/properties-core.md)** :

    **Набор (RunningTotal, RunningTotal + TextInput1)**

    Устанавливает простое наличие этой формулы **RunningTotal** как глобальной переменной, которая содержит число из-за **+** оператор. Вы можете ссылаться на **RunningTotal** в любом месте приложения. Каждый раз, когда пользователь открывает это приложение **RunningTotal** начальное значение из *пустой*.

    При первом выборе **добавить** кнопку и **[задать](functions/function-set.md)** выполняется, **RunningTotal** присвоено значение  **RunningTotal + TextInput1**.

    ![Свойство OnSelect кнопки "Добавить" имеет значение Set, функция](media/working-with-variables/global-variable-1.png)

4. Чтобы нарастающий итог становился равным **0**, когда пользователь нажимает кнопку **Очистить**, задайте в качестве значения его свойства **[OnSelect](controls/properties-core.md)** следующую формулу:

    **Set( RunningTotal, 0 )**

    ![Свойство OnSelect кнопки «Очистить» имеет значение Set, функция](media/working-with-variables/global-variable-2.png)

5. Добавьте элемент управления **[Метка](controls/control-text-box.md)** и задайте для его свойства **[Text](controls/properties-core.md)** значение **RunningTotal**.

    Эта формула пересчитывается автоматически, а для пользователя отображается значение **RunningTotal**, которое изменяется в зависимости от нажимаемых им кнопок.

    ![Текст метки задано имя переменной](media/working-with-variables/global-variable-3.png)

6. Перейдите в режим предварительного просмотра приложения, и вы увидите, что наш арифмометр работает, как описано выше. Введите число в текстовое поле и нажмите кнопку **Добавить** несколько раз. Выполнив эти действия, вернитесь к разработке, нажав клавишу ESC.

    ![Текстовое поле содержит значение, а метка нарастающий итог](media/working-with-variables/global-variable-4.png)

7. Чтобы отобразить значение глобальной переменной, выберите **файл** меню и выберите **переменных** на левой панели.

    ![Параметр переменные в меню "файл"](media/working-with-variables/global-variable-file-1.png)

8. Чтобы отобразить все места, где определяется и используется переменная, выберите его.

    ![Список расположение, где используется переменная](media/working-with-variables/global-variable-file-2.png)

## <a name="types-of-variables"></a>Типы переменных

PowerApps поддерживает три типа переменных:

| Тип переменных | Область действия | Описание | Функции, которые составляют |
| --- | --- | --- | --- |
| Глобальные переменные |App |Самые простые в использовании. В них могут храниться любые значения, в том числе числа, текстовые строки, логические значения, записи, таблицы и т. п., на которые можно ссылаться из любого места в приложении. |[**Set**](functions/function-set.md) |
| Переменные контекста |Экран |Отлично подходят для передачи значений на экран, похожи на параметры для процедур на других языках. Можно ссылаться из только один экран. |[**UpdateContext**](functions/function-updatecontext.md)<br>[**Navigate**](functions/function-navigate.md) |
| Коллекции |App |Содержит таблицу, которая может указываться в любом месте в приложении. Позволяет изменять содержимое таблицы вместо того, чтобы задать все содержимое сразу. Можно сохранить на локальном устройстве для дальнейшего использования. |[**Collect**](functions/function-clear-collect-clearcollect.md)<br>[**ClearCollect**](functions/function-clear-collect-clearcollect.md) |

## <a name="create-and-remove-variables"></a>Создание и удаление переменных

Все переменные создаются неявно, когда они присутствуют в **задать**, **UpdateContext**, **Navigate**, **собирать**, или  **ClearCollect** функции. Для объявления переменной и ее типа, нужно только указывать его в любом из этих функций в любом месте в приложении. Ни одна из этих функций создания переменных. они только заполните переменные со значениями. Вы никогда не объявлять переменные явно может в другое средство программирования, а все ввода является неявным из использования.

Например, возможно, элемент управления button с **OnSelect** формулу, равным **набора (X, 1)** . Эта формула устанавливает **X** как переменная с типом числа. Можно использовать **X** в формулах как число и эта переменная имеет значение *пустой* после открытия приложения, но до нажатия кнопки. При нажатии кнопки задается **X** значение **1**.

Если вы добавили другой кнопку и задайте его **OnSelect** свойства **набора (X, «Hello»)** , может возникнуть ошибка, так как тип (строка текста) не совпадает с типом в предыдущем **задать**(номер). Все неявные определения переменной необходимо согласовать типа. Опять же, все это произошло, так как вы упомянули **X** в формулах, не так, как одну из этих формул бы выполнялся.

Удалить переменную, удалив все **задать**, **UpdateContext**, **Navigate**, **собирать**, или **ClearCollect**  функций, которые неявно устанавливать переменной. Без этих функций переменная не существует. Также необходимо удалить все ссылки на переменную, так как они приведут к ошибке.

## <a name="variable-lifetime-and-initial-value"></a>Время существования переменной и начальное значение

Все переменные хранятся в памяти во время выполнения приложения. После закрытия приложения, хранящиеся в переменных значения утрачиваются.

Содержимое переменной можно хранить в источнике данных с помощью **Patch** или **собирать** функции. Можно также хранить значения в коллекции на локальном устройстве с помощью [ **SaveData** ](functions/function-savedata-loaddata.md) функции.

Когда пользователь открывает приложение, все переменные имеют начальное значение *пустой*.

## <a name="reading-variables"></a>Чтение переменных

Имя переменной используется прочитать его значение. Например можно определить переменную с помощью этой формулы:

`Set( Radius, 12 )`

После этого можно просто использовать **Radius** любого места, можно использовать ряд, что он будет заменен **12**:

`Pi() * Power( Radius, 2 )`

Если вы предоставите переменную контекста совпадает с именем глобальной переменной или коллекции, переменная контекста имеет приоритет. Однако можно по-прежнему ссылаться на глобальную переменную или коллекции при использовании [оператор устранения неоднозначности](functions/operators.md#disambiguation-operator) **@[Radius]** .

## <a name="use-a-context-variable"></a>Использовать переменную контекста

Давайте попробуем создать наш арифмометр, используя переменную контекста вместо глобальной переменной.

Принцип их действия заключается в следующем:

* Неявно установления и задать переменные контекста с помощью **[UpdateContext](functions/function-updatecontext.md)** или **[Navigate](functions/function-navigate.md)** функции. При запуске приложения, начальным значением всех переменных контекста является *пустой*.
* Обновите переменные контекста с записями. В других средствах программирования для присвоения значений обычно используется оператор «=», например «x = 1». Переменные контекста, используйте **{x: 1}** вместо этого. При использовании переменной контекста, указав имя напрямую без использования синтаксиса записи.
* Можно также задать переменную контекста, при использовании **[Navigate](functions/function-navigate.md)** функции для отображения экрана. Если вы считаете, что экрана как своего рода процедура или подпрограмма, этот подход похож на передачи параметров в других средствах программирования.
* За исключением функции **[Navigate](functions/function-navigate.md)** , переменные контекста ограничены контекстом одного экрана (того, на котором им было присвоено их имя). Их нельзя использовать или задать вне данного контекста.
* В переменных контекста может храниться любое значение, в том числе строки, числа, записи и [таблицы](working-with-tables.md).

Перестроим наш арифмометр, воспользовавшись переменными контекста.

1. Добавьте элемент управления текстовым вводом с именем **TextInput1** и две кнопки с именами **Button1** и **Button2**.

2. Задайте для свойства **[Text](controls/properties-core.md)** элемента управления **Button1** значение **"Add"** , а для свойства **Text** элемента управления **Button2** — значение **"Clear"** .

3. Чтобы нарастающий итог обновлялся, когда пользователь нажимает кнопку **Добавить**, задайте следующую формулу в качестве значения свойства **[OnSelect](controls/properties-core.md)** :

    **UpdateContext ({RunningTotal: RunningTotal + TextInput1})**

    Устанавливает простое наличие этой формулы **RunningTotal** как переменную контекста, содержащее номер из-за **+** оператор. Вы можете ссылаться на **RunningTotal** в любом месте этого экрана. Каждый раз, когда пользователь открывает это приложение **RunningTotal** начальное значение из *пустой*.

    При первом выборе **добавить** кнопку и **[UpdateContext](functions/function-updatecontext.md)** выполняется, **RunningTotal** присваивается значение **RunningTotal + TextInput1**.

    ![Свойства OnSelect кнопки "Добавить"](media/working-with-variables/context-variable-1.png)

4. Чтобы нарастающий итог становился равным **0**, когда пользователь нажимает кнопку **Очистить**, задайте в качестве значения его свойства **[OnSelect](controls/properties-core.md)** следующую формулу:

    **UpdateContext ({RunningTotal: 0 } )**

    Опять же **[UpdateContext](functions/function-updatecontext.md)** используется в формуле **UpdateContext ({RunningTotal: 0 } )** .

    ![Свойства OnSelect кнопки «Очистить»](media/working-with-variables/context-variable-2.png)

5. Добавьте элемент управления **[Метка](controls/control-text-box.md)** и задайте для его свойства **[Text](controls/properties-core.md)** значение **RunningTotal**.

    Эта формула пересчитывается автоматически, а для пользователя отображается значение **RunningTotal**, которое изменяется в зависимости от нажимаемых им кнопок.

    ![Свойство текста метки](media/working-with-variables/context-variable-3.png)

6. Перейдите в режим предварительного просмотра приложения, и вы увидите, что наш арифмометр работает, как описано выше. Введите число в текстовое поле и нажмите кнопку **Добавить** несколько раз. Выполнив эти действия, вернитесь к разработке, нажав клавишу ESC.

    ![Элемент управления текстовое поле отображает значение и метка показано общее с](media/working-with-variables/context-variable-4.png)

7. Вы можете задать значение переменной контекста, перейдя на экран. Этот вариант используется для передачи контекста или параметров с одного экрана на другой. Для демонстрации этого метода, вставьте экран, кнопки и задайте его **OnSelect** следующую формулу:

    **Navigate( Screen1, None, { RunningTotal: -1000 } )**

    ![Свойства OnSelect кнопки](media/working-with-variables/context-variable-5.png)

    Удерживая нажатой клавишу Alt, выберите эту кнопку, чтобы как Показать **Screen1** и задайте переменную контекста **RunningTotal** для -1000.

    ![Screen1 открыт](media/working-with-variables/context-variable-6.png)

8. Чтобы отобразить значение переменной контекста, выберите **файл** меню, а затем выберите **переменных** на левой панели.

    ![Параметр переменные в меню "файл"](media/working-with-variables/context-variable-file-1.png)

9. Чтобы показать, где определяется и используется для переменной контекста, выберите его.

    ![Список, где используется переменная](media/working-with-variables/context-variable-file-2.png)

## <a name="use-a-collection"></a>Использовать коллекцию

Наконец, давайте попробуем создать наш арифмометр с помощью коллекции.  Так как коллекция хранит таблицу, которую можно легко изменить, в этом арифмометре каждое вводимое значение будет сохранятся на "бумажной ленте".

Принцип действия коллекций описан ниже.

* Создайте и настройте коллекции с помощью функции **[ClearCollect](functions/function-clear-collect-clearcollect.md)** .  Вместо этого можно использовать функцию **[Collect](functions/function-clear-collect-clearcollect.md)** , но фактически для этого потребуется создать другую переменную, а не заменить имеющуюся.  
* Коллекция — это типа источника данных, который можно представить как таблицу. Чтобы получить доступ к отдельному значению в коллекции, воспользуйтесь функцией **[First](functions/function-first-last.md)** и извлеките одно поле из результирующей записи. Если вы использовали одно значение с **[ClearCollect](functions/function-clear-collect-clearcollect.md)** , это будет поле **Value**, как в этом примере:<br>
**First(** *VariableName* **).Value**

Создадим арифмометр, воспользовавшись коллекцией.

1. Добавьте элемент управления **[Текстовое поле](controls/control-text-input.md)** с именем **TextInput1** и две кнопки с именами **Button1** и **Button2**.

2. Задайте для свойства **[Text](controls/properties-core.md)** элемента управления **Button1** значение **"Add"** , а для свойства **Text** элемента управления **Button2** — значение **"Clear"** .

3. Чтобы нарастающий итог обновлялся, когда пользователь нажимает кнопку **Добавить**, задайте следующую формулу в качестве значения свойства **[OnSelect](controls/properties-core.md)** :

    **Collect( PaperTape, TextInput1.Text )**

    Устанавливает простое наличие этой формулы **PaperTape** как коллекция, содержащая один столбец таблицы текстовых строк. Вы можете ссылаться на **PaperTape** в любом месте этого приложения. Каждый раз, когда пользователь открывает это приложение **PaperTape** будут пустой таблицей.

    При запуске следующую формулу, он добавляет новое значение в конец коллекции. Так, как мы добавляем одно значение, **собирать** автоматически помещается в таблицу с одним столбцом, и имя столбца является **значение**, который будет использоваться в дальнейшем.

    ![Свойства OnSelect кнопки "Добавить"](media/working-with-variables/papertape-1.png)

4. Чтобы очистить бумажную ленту, когда пользователь выбирает **снимите** кнопку, задайте его **[OnSelect](controls/properties-core.md)** следующую формулу:

    **Clear( PaperTape )**

    ![Свойства OnSelect кнопки «Очистить»](media/working-with-variables/papertape-2.png)

5. Для отображения нарастающего итога добавьте метку и задайте для нее в качестве значения свойства **[Text](controls/properties-core.md)** следующую формулу:

    **Sum( PaperTape, Value )**

    ![Свойство текста метки](media/working-with-variables/papertape-3.png)

6. Чтобы запустить арифмометр, нажмите F5, чтобы перейти в режим предварительного просмотра, введите число в текстовом поле и нажмите кнопки.

    ![Показано ввода текста, значением и Показать метку нарастающий итог](media/working-with-variables/papertape-run-1.png)

7. Нажмите клавишу ESC, чтобы вернуться в рабочую область по умолчанию.

8. Чтобы отобразить "бумажную ленту", вставьте элемент управления **Таблица данных** и задайте его свойству **[Items](controls/properties-core.md)** следующую формулу:

    **PaperTape**

    На панели справа выберите **значение** столбца, чтобы отобразить его.

    ![Таблицы данных, которая содержит значения, добавляемого в коллекцию](media/working-with-variables/papertape-4.png)

9. Чтобы просмотреть значения в коллекции, выберите в меню **Файл** пункт **Коллекции**.

    ![Предварительная версия PaperTape коллекции](media/working-with-variables/papertape-file.png)

10. Чтобы сохранить и извлечь коллекцию, добавьте две дополнительные кнопки и задайте их **текст** свойства **нагрузки** и **Сохранить**. Задайте **OnSelect** свойство **нагрузки** кнопки следующую формулу:

     **Clear( PaperTape ); LoadData( PaperTape, "StoredPaperTape", true )**

     Необходимо сначала очистить коллекцию, так как **LoadData** добавит хранящиеся значения в конец коллекции.

     ![Свойства OnSelect кнопки нагрузки](media/working-with-variables/papertape-5.png)

11. Задайте **OnSelect** свойство **Сохранить** кнопки следующую формулу:

     **SaveData( PaperTape, "StoredPaperTape" )**

     ![Свойство OnSelect * кнопки «Сохранить»](media/working-with-variables/papertape-6.png)

12. Перейдите в режим предварительного просмотра снова, нажав клавишу F5, введите числа в элементе управления для ввода текста и нажмите кнопки. Нажмите кнопку **Сохранить**. Закройте и повторно загрузить приложение и выберите **нагрузки** кнопку, чтобы повторно загрузить коллекцию.

> [!NOTE]
> **SaveData** и **LoadData** функции в PowerApps Mobile, но не в PowerApps Studio или веб-проигрыватель для PowerApps.