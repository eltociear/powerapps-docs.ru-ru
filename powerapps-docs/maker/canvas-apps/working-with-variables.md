---
title: Общие сведения о переменных в приложениях на основе холста | Документы Майкрософт
description: Справочные сведения о работе с состояниями, контекстными переменными и коллекциями в приложениях на основе холста
author: gregli-msft
manager: kvivek
ms.service: powerapps
ms.topic: conceptual
ms.custom: canvas
ms.reviewer: tapanm
ms.date: 02/28/2019
ms.author: gregli
search.audienceType:
- maker
search.app:
- PowerApps
ms.openlocfilehash: 4dcc00f20de3a16f1f3125e8840f2f6d74feff32
ms.sourcegitcommit: 6b27eae6dd8a53f224a8dc7d0aa00e334d6fed15
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/03/2019
ms.locfileid: "74733156"
---
# <a name="understand-canvas-app-variables-in-power-apps"></a>Знакомство с переменными приложения Canvas в Power Apps

Если вы использовали другое средство программирования, например Visual Basic или JavaScript, у вас может возникнуть вопрос: **Где переменные?** Power Apps немного отличается и требует другого подхода. Вместо того, чтобы при создании приложения на основе холста мыслить в категориях переменных, спросите себя: **Как это делается в Excel?**

Возможно, в других средствах вы явно выполняли вычисления и хранили результаты в переменной. Однако приложения Power Apps и Excel автоматически перечисляют формулы при изменении входных данных, поэтому обычно создавать и обновлять переменные не требуется. Применяя такой подход по мере возможности, можно легко создавать и обслуживать приложения, полностью понимая принцип их работы.

В некоторых случаях необходимо использовать переменные в Power Apps, которые расширяют модель Excel путем добавления [формул поведения](working-with-formulas-in-depth.md). Эти формулы, например, выполняются, когда пользователь нажимает кнопку. В формуле поведения зачастую удобно задать переменную, которую можно использовать в других формулах.

Как правило, использовать переменные нежелательно. Однако иногда только с их помощью можно обеспечить желаемые возможности. Переменные неявно создаются и вводятся, когда они появляются в функциях, которые задают их значения. 

## <a name="translate-excel-into-power-apps"></a>Перевод Excel в Power Apps

### <a name="excel"></a>Excel

Давайте посмотрим, как работает Excel. Ячейка может содержать значение, например число, строку или формулу, в которой используются значения других ячеек. После того как пользователь вводит другое значение в ячейку, Excel автоматически пересчитывает все формулы, которые зависят от нового значения. При этом для обеспечения такого поведения не нужно ничего программировать.

В следующем примере ячейке **a3** присваивается формула **a1 + a2**. Если изменяется значение **a1** или **a2** , **a3** автоматически пересчитывается для отражения изменений. Это поведение не требует написания кода вне формулы.

![Анимация повторного вычисления суммы двух чисел в Excel](media/working-with-variables/excel-recalc.gif)

В Excel нет переменных. Значение ячейки, содержащей формулу, изменяется в зависимости от входных данных, но при этом нет возможности запомнить результат формулы и сохранить его в ячейке или в любом другом месте. При изменении значения ячейки может измениться вся таблица, а все ранее вычисляемые значения будут утрачены. Пользователь Excel может копировать и вставлять ячейки, но это нужно делать вручную. С помощью формул выполнить такую операцию невозможно.

### <a name="power-apps"></a>Power Apps

Приложения, создаваемые в приложениях Power Apps, работают практически так же, как Excel. Вместо обновления ячеек можно добавить элементы управления в любом месте на экране и присвоить им имена, чтобы их можно было использовать в формулах.

Например, можно реплицировать поведение Excel в приложении, добавив элемент управления **[Label](controls/control-text-box.md)** , именуемый **Label1**, и два элемента управления **[вводом текста](controls/control-text-input.md)** с именами **TextInput1** и **TextInput2**. Если затем задать для свойства **[Text](controls/properties-core.md)** метки **Label1** значение **TextInput1 + TextInput2**, то всегда будет отображаться сумма всех чисел в **TextInput1** и **TextInput2** автоматически.

![Вычисление суммы двух чисел в Power Apps](media/working-with-variables/recalc1.png)

Обратите внимание, что выбран элемент управления **Label1** , отображающий его **[текстовую](controls/properties-core.md)** формулу в строке формул в верхней части экрана. В данном случае она выглядит таким образом: **TextInput1 + TextInput2**. Эта формула создает между этими элементами управления такую же зависимость, как между ячейками в книге Excel.  Давайте изменим значение **TextInput1**:

![Анимация вычисления суммы двух чисел в Power Apps](media/working-with-variables/recalc2.gif)

Формула для **Label1** была автоматически пересчитана, отображая новое значение.

В Power Apps формулы можно использовать для определения не только основного значения элемента управления, но также таких свойств, как форматирование. В следующем примере формула для свойства **[Color](controls/properties-color-border.md)** метки обеспечит автоматическое отображение отрицательных значений красным цветом. Функция **[If](functions/function-if.md)** очень похожа на ту, которая используется в Excel.

`If( Value(Label1.Text) < 0, Red, Black )`

![Анимация условного форматирования](media/working-with-variables/recalc-color.gif)

Формулы можно использовать в самых разнообразных сценариях.

* Используя GPS-модуль устройства, элемент управления картой может отобразить ваше текущее расположение с помощью формулы, использующей значения **Location.Latitude** и **Location.Longitude**.  При перемещении карта будет автоматически отслеживать расположение.
* Другие пользователи могут обновлять [источники данных](working-with-data-sources.md).  Например, другие участники группы могут обновлять элементы в списке SharePoint.  При обновлении источника данных все зависимые формулы автоматически пересчитываются, в результате чего отображаются обновленные данные. Дополнив этот пример, можно задать коллекцию свойства **[Items](controls/properties-core.md)** в формуле **Filter( SharePointList )** , что обеспечит автоматическое отображение заново отфильтрованного набора [записей](working-with-tables.md#records).

### <a name="benefits"></a>Преимущества

Использование формул для создания приложений дает множество преимуществ.

* Если вы знакомы с Excel, вы узнаете о Power Apps. Модель и язык формул у них одинаковы.
* Если вы использовали другие средства программирования, представьте себе, сколько бы вам пришлось написать кода, чтобы обеспечить вычисления, приведенные в этих примерах.  В Visual Basic необходимо написать обработчик событий для события изменения в каждом текстовом поле.  Код, необходимый для выполнения вычисления в каждом из них, избыточен и может не синхронизироваться, или же вам придется написать общие подпрограммы.  В Power apps все это можно выполнить с помощью одной однострочной формулы.
* Чтобы понять, откуда поступает текст **Label1**, вы точно знаете, где именно она выглядит: формула в свойстве **[Text](controls/properties-core.md)** .  Повлиять на текст данного элемента управления другими способами невозможно.  В традиционных средствах программирования любые подпрограммы и обработчики событий могут изменить значение метки из любого места в программе.  Из-за этого иногда сложно отследить, где и когда была изменена переменная.
* Изменив положение ползунка, пользователь может передумать и вернуть его в исходное положение.  В результате как бы ничего не происходит: приложение отображает такие же значения элемента управления, как и раньше.  Все это происходит без каких-либо последствий, так что можно смело экспериментировать и пробовать разные варианты, что в Excel попросту невозможно.  

Как правило, если желаемого эффекта можно добиться с помощью формулы, лучше использовать именно ее. Позвольте обработчику формул в Power apps работать.  

## <a name="know-when-to-use-variables"></a>Ситуации, в которых имеет смысл использовать переменные

Давайте изменим наш простой сумматор так, чтобы он функционировал по принципу старинного арифмометра, используя нарастающий итог. При нажатии кнопки **Добавить** число добавляется к нарастающему итогу. При нажатии кнопки **Очистить** нарастающий итог обнуляется.

| Монитор | Description |
|----|----|
| <style>img {max-width: None}</style> ![приложение с элементом управления текстового ввода, меткой и двумя кнопками](media/working-with-variables/button-changes-state-1.png) | При запуске приложения итоговая сумма равна 0.<br><br>Красная точка представляет палец пользователя в поле ввода текста, где пользователь вводит **77**. |
| ![Элемент управления вводом текста содержит 77, и кнопка "Добавить" нажата](media/working-with-variables/button-changes-state-2.png) | Пользователь нажимает кнопку **Добавить** . |
| ![Сумма равна 77, и к ней добавляется еще одна 77](media/working-with-variables/button-changes-state-3.png) | 77 добавляется в итоговое значение.<br><br>Пользователь снова нажмет кнопку **Добавить** . |
| ![Сумма 154 перед очисткой.](media/working-with-variables/button-changes-state-4.png) | 77 снова добавляется к общему итогу, что приводит к 154.<br><br>Пользователь нажимает кнопку **clear (очистить** ). |
| ![Итог удаляется.](media/working-with-variables/button-changes-state-5.png) | Итоговое значение сбрасывается в 0. |

Наш арифмометр использует то, чего нет в Excel: кнопки. В этом приложении для вычисления нарастающих итогов нельзя использовать только формулы, поскольку их значение зависит от ряда действий, которые выполняет пользователь. Вместо этого нарастающий итог записывается и обновляется вручную. Большинство средств программирования сохраняет эти сведения в *переменной*.

Иногда, чтобы приложения вели себя необходимым образом, требуется использовать переменные.  Однако такой подход применим с некоторыми оговорками.

* Нарастающий итог необходимо обновлять вручную. При автоматическом пересчете эта операция не выполняется.
* Нарастающий итог больше нельзя рассчитать на основе значений других элементов управления. Он зависит от того, сколько раз пользователь нажимает кнопку **Добавить** и какое значение при этом содержится в элементе управления текстовым вводом на момент ее нажатия. Ввел ли пользователь 77 и нажал **Добавить** дважды или же указал 24 и 130 в качестве слагаемых? После того как итог станет равным 154, определить разницу невозможно.
* Итог может изменяться по разным причинам. В этом примере к его изменению может приводить нажатие кнопок **Добавить** и **Очистить**. Как определить, какая кнопка вызывает проблему, если приложение не работает должным образом?

## <a name="use-a-global-variable"></a>Использовать глобальную переменную

Чтобы создать арифмометр, нам понадобится переменная для хранения нарастающего итога. Простейшими переменными для работы в Power apps являются *глобальные переменные*.  

Принцип их действия заключается в следующем:

* Значение глобальной переменной задается с помощью функции **[Set](functions/function-set.md)** .  **Set( MyVar, 1 )** задает для глобальной переменной **MyVar** значение **1**.
* Используйте эту глобальную переменную, ссылаясь на ее имя в функции **Set**.  В этом случае **MyVar** возвращает значение **1**.
* В глобальных переменных может храниться любое значение, в том числе строки, числа, записи и [таблицы](working-with-tables.md).

Перестроим наш арифмометр, воспользовавшись глобальными переменными.

1. Добавьте элемент управления текстовым вводом с именем **TextInput1** и две кнопки с именами **Button1** и **Button2**.

2. Задайте для свойства **[Text](controls/properties-core.md)** элемента управления **Button1** значение **"Add"** , а для свойства **Text** элемента управления **Button2** — значение **"Clear"** .

3. Чтобы нарастающий итог обновлялся, когда пользователь нажимает кнопку **Добавить**, задайте следующую формулу в качестве значения свойства **[OnSelect](controls/properties-core.md)** :

    **Set (Руннингтотал, Руннингтотал + TextInput1)**

    Только эта формула устанавливает **руннингтотал** как глобальную переменную, которая содержит число из-за оператора **+** . Вы можете ссылаться на **руннингтотал** в любом месте приложения. Когда пользователь открывает это приложение, **руннингтотал** имеет *пустое*начальное значение.

    В первый раз, когда пользователь нажимает кнопку **Добавить** и **[настраивает](functions/function-set.md)** запуски, для **Руннингтотал** задается значение **руннингтотал + TextInput1**.

    ![Для свойства OnSelect кнопки Add задано значение SET Function.](media/working-with-variables/global-variable-1.png)

4. Чтобы нарастающий итог становился равным **0**, когда пользователь нажимает кнопку **Очистить**, задайте в качестве значения его свойства **[OnSelect](controls/properties-core.md)** следующую формулу:

    **Set( RunningTotal, 0 )**

    ![Для свойства OnSelect кнопки Clear задано значение SET Function.](media/working-with-variables/global-variable-2.png)

5. Добавьте элемент управления **[Метка](controls/control-text-box.md)** и задайте для его свойства **[Text](controls/properties-core.md)** значение **RunningTotal**.

    Эта формула пересчитывается автоматически, а для пользователя отображается значение **RunningTotal**, которое изменяется в зависимости от нажимаемых им кнопок.

    ![Свойству Text метки присваивается имя переменной](media/working-with-variables/global-variable-3.png)

6. Перейдите в режим предварительного просмотра приложения, и вы увидите, что наш арифмометр работает, как описано выше. Введите число в текстовое поле и нажмите кнопку **Добавить** несколько раз. Выполнив эти действия, вернитесь к разработке, нажав клавишу ESC.

    ![Элемент управления вводом текста содержит значение, а метка содержит промежуточный итог](media/working-with-variables/global-variable-4.png)

7. Чтобы отобразить значение глобальной переменной, выберите меню **файл** и щелкните **переменные** в области слева.

    ![Параметр "переменные" в меню "файл"](media/working-with-variables/global-variable-file-1.png)

8. Чтобы отобразить все места, где переменная определена и используется, выберите ее.

    ![Список расположения, где используется переменная](media/working-with-variables/global-variable-file-2.png)

## <a name="types-of-variables"></a>Типы переменных

В Power Apps есть три типа переменных:

| Тип переменных | Область действия | Description | Функции, устанавливающие |
| --- | --- | --- | --- |
| Глобальные переменные |App |Самые простые в использовании. В них могут храниться любые значения, в том числе числа, текстовые строки, логические значения, записи, таблицы и т. п., на которые можно ссылаться из любого места в приложении. |[**Set**](functions/function-set.md) |
| Переменные контекста |Экран |Отлично подходят для передачи значений на экран, похожи на параметры для процедур на других языках. Может ссылаться только на один экран. |[**UpdateContext**](functions/function-updatecontext.md)<br>[**Navigate**](functions/function-navigate.md) |
| Коллекции |App |Содержит таблицу, на которую можно ссылаться из любого места в приложении. Позволяет изменять содержимое таблицы вместо того, чтобы задать все содержимое сразу. Можно сохранить на локальном устройстве для дальнейшего использования. |[**Collect**](functions/function-clear-collect-clearcollect.md)<br>[**ClearCollect**](functions/function-clear-collect-clearcollect.md) |

## <a name="create-and-remove-variables"></a>Создание и удаление переменных

Все переменные создаются неявно, если они появляются в функции **Set**, **упдатеконтекст**, **navigate**, или **клеарколлект** . Чтобы объявить переменную и ее тип, необходимо включить ее в любую из этих функций в любом месте приложения. Ни одна из этих функций не создает переменные; они заполняют только переменные значениями. Переменные не объявляются явным образом, как это возможно в другом средстве программирования, и вся типизация не является неявной.

Например, у вас может быть элемент управления Button с формулой **OnSelect** , равным **Set (X, 1)** . Эта формула устанавливает **X** как переменную с типом числа. Можно использовать **X** в формулах как число, и эта переменная имеет *пустое* значение после открытия приложения, но перед нажатием кнопки. При нажатии кнопки вы присваиваете параметру **X** значение **1**.

Если вы добавили еще одну кнопку и задали для нее свойство **OnSelect** **(X, "Hello")** , возникнет ошибка, так как тип (текстовая строка) не соответствует типу в предыдущем **наборе** (Number). Все неявные определения переменной должны быть согласованы по типу. Опять же, это произошло из-за того, что вы упомянули **X** в формулах, а не потому, что какая-либо из этих формул реально выполнялась

Удалите переменную, удалив все функции **Set**, **упдатеконтекст**, **navigate**, **собирающего**или **клеарколлект** , которые неявно устанавливают переменную. Без этих функций переменная не существует. Также необходимо удалить все ссылки на переменную, так как они будут вызывать ошибку.

## <a name="variable-lifetime-and-initial-value"></a>Время существования переменной и начальное значение

Во время выполнения приложения все переменные хранятся в памяти. После закрытия приложения значения, удерживаемые переменными, теряются.

Содержимое переменной можно хранить в источнике данных с **помощью функций** **Patch** или "функция". Можно также хранить значения в коллекциях на локальном устройстве с помощью функции [**SaveData**](functions/function-savedata-loaddata.md) .

Когда пользователь открывает приложение, все переменные имеют начальное *пустое*значение.

## <a name="reading-variables"></a>Считывание переменных

Имя переменной используется для считывания ее значения. Например, можно определить переменную с помощью следующей формулы:

`Set( Radius, 12 )`

Затем можно просто использовать **RADIUS** в любом месте, где можно использовать число, и оно будет заменено на **12**:

`Pi() * Power( Radius, 2 )`

Если переменной контекста присваивается то же имя, что и глобальная переменная или коллекция, приоритет имеет переменная контекста. Однако вы по-прежнему можете ссылаться на глобальную переменную или коллекцию, если используется [оператор устранения неоднозначности](functions/operators.md#disambiguation-operator) **@ [RADIUS]** .

## <a name="use-a-context-variable"></a>Использовать переменную контекста

Давайте попробуем создать наш арифмометр, используя переменную контекста вместо глобальной переменной.

Принцип их действия заключается в следующем:

* Вы неявно устанавливаете и устанавливаете переменные контекста с помощью функции **[упдатеконтекст](functions/function-updatecontext.md)** или **[navigate](functions/function-navigate.md)** . При запуске приложения начальное значение всех переменных контекста будет *пустым*.
* Переменные контекста обновляются записями. В других средствах программирования для присвоения значений обычно используется оператор «=», например «x = 1». Для переменных контекста вместо этого используется **{ x: 1 }** . При использовании переменной контекста используйте ее имя напрямую без синтаксиса записи.
* Можно также задать переменную контекста при использовании функции **[навигации](functions/function-navigate.md)** для отображения экрана. Если вы считаете, что экран является разновидностью процедуры или подпрограммы, этот подход напоминает передачу параметров в другие средства программирования.
* За исключением функции **[Navigate](functions/function-navigate.md)** , переменные контекста ограничены контекстом одного экрана (того, на котором им было присвоено их имя). Их нельзя использовать или задать вне данного контекста.
* В переменных контекста может храниться любое значение, в том числе строки, числа, записи и [таблицы](working-with-tables.md).

Перестроим наш арифмометр, воспользовавшись переменными контекста.

1. Добавьте элемент управления текстовым вводом с именем **TextInput1** и две кнопки с именами **Button1** и **Button2**.

2. Задайте для свойства **[Text](controls/properties-core.md)** элемента управления **Button1** значение **"Add"** , а для свойства **Text** элемента управления **Button2** — значение **"Clear"** .

3. Чтобы нарастающий итог обновлялся, когда пользователь нажимает кнопку **Добавить**, задайте следующую формулу в качестве значения свойства **[OnSelect](controls/properties-core.md)** :

    **Упдатеконтекст ({Руннингтотал: Руннингтотал + TextInput1})**

    Только эта формула создает **руннингтотал** в качестве переменной контекста, содержащей число из-за оператора **+** . Вы можете ссылаться на **руннингтотал** в любом месте этого экрана. Когда пользователь открывает это приложение, **руннингтотал** имеет *пустое*начальное значение.

    В первый раз, когда пользователь нажимает кнопку **Add (добавить** ) и **[упдатеконтекст](functions/function-updatecontext.md)** запускается, для **Руннингтотал** задается значение **руннингтотал + TextInput1**.

    ![Свойство OnSelect кнопки "Добавить"](media/working-with-variables/context-variable-1.png)

4. Чтобы нарастающий итог становился равным **0**, когда пользователь нажимает кнопку **Очистить**, задайте в качестве значения его свойства **[OnSelect](controls/properties-core.md)** следующую формулу:

    **UpdateContext( { RunningTotal: 0 } )**

    Опять же, в формуле **UpdateContext( { RunningTotal: 0 } )** используется **[UpdateContext](functions/function-updatecontext.md)** .

    ![Свойство OnSelect кнопки Clear](media/working-with-variables/context-variable-2.png)

5. Добавьте элемент управления **[Метка](controls/control-text-box.md)** и задайте для его свойства **[Text](controls/properties-core.md)** значение **RunningTotal**.

    Эта формула пересчитывается автоматически, а для пользователя отображается значение **RunningTotal**, которое изменяется в зависимости от нажимаемых им кнопок.

    ![Свойство Text метки](media/working-with-variables/context-variable-3.png)

6. Перейдите в режим предварительного просмотра приложения, и вы увидите, что наш арифмометр работает, как описано выше. Введите число в текстовое поле и нажмите кнопку **Добавить** несколько раз. Выполнив эти действия, вернитесь к разработке, нажав клавишу ESC.

    ![Элемент управления вводом текста отображает значение, а метка показывает промежуточный итог](media/working-with-variables/context-variable-4.png)

7. Вы можете задать значение переменной контекста, перейдя на экран. Этот вариант используется для передачи контекста или параметров с одного экрана на другой. Чтобы продемонстрировать этот метод, вставьте экран, вставьте кнопку и задайте для его свойства **OnSelect** следующую формулу:

    **Navigate( Screen1, None, { RunningTotal: -1000 } )**

    ![Свойство OnSelect кнопки](media/working-with-variables/context-variable-5.png)

    Удерживая нажатой клавишу Alt, нажмите эту кнопку, чтобы отобразить **Screen1** и установить переменную контекста **руннингтотал** в значение-1000.

    ![Screen1 открыт](media/working-with-variables/context-variable-6.png)

8. Чтобы отобразить значение переменной контекста, в меню **файл** выберите пункт **переменные** в области слева.

    ![Параметр "переменные" в меню "файл"](media/working-with-variables/context-variable-file-1.png)

9. Чтобы узнать, где определена и использована переменная контекста, выберите ее.

    ![Список мест, где используется переменная](media/working-with-variables/context-variable-file-2.png)

## <a name="use-a-collection"></a>Использование коллекции

Наконец, давайте попробуем создать наш арифмометр с помощью коллекции.  Так как коллекция хранит таблицу, которую можно легко изменить, в этом арифмометре каждое вводимое значение будет сохранятся на "бумажной ленте".

Принцип действия коллекций описан ниже.

* Создайте и настройте коллекции с помощью функции **[ClearCollect](functions/function-clear-collect-clearcollect.md)** .  Вместо этого можно использовать функцию **[Collect](functions/function-clear-collect-clearcollect.md)** , но фактически для этого потребуется создать другую переменную, а не заменить имеющуюся.  
* Коллекция — это типа источника данных, который можно представить как таблицу. Чтобы получить доступ к отдельному значению в коллекции, воспользуйтесь функцией **[First](functions/function-first-last.md)** и извлеките одно поле из результирующей записи. Если вы использовали одно значение с **[ClearCollect](functions/function-clear-collect-clearcollect.md)** , это будет поле **Value**, как в этом примере:<br>
**First(** *VariableName* **).Value**

Создадим арифмометр, воспользовавшись коллекцией.

1. Добавьте элемент управления **[Текстовое поле](controls/control-text-input.md)** с именем **TextInput1** и две кнопки с именами **Button1** и **Button2**.

2. Задайте для свойства **[Text](controls/properties-core.md)** элемента управления **Button1** значение **"Add"** , а для свойства **Text** элемента управления **Button2** — значение **"Clear"** .

3. Чтобы нарастающий итог обновлялся, когда пользователь нажимает кнопку **Добавить**, задайте следующую формулу в качестве значения свойства **[OnSelect](controls/properties-core.md)** :

    **Collect( PaperTape, TextInput1.Text )**

    Единственное существование этой формулы устанавливает **папертапе** в качестве коллекции, содержащей таблицу текстовых строк с одним столбцом. Вы можете ссылаться на **папертапе** в любом месте этого приложения. Каждый раз, когда пользователь открывает это приложение, **папертапе** является пустой таблицей.

    При выполнении этой формулы новое значение добавляется в конец коллекции. Поскольку мы добавляем одно **значение, оно** автоматически помещает его в таблицу с одним столбцом, а имя столбца — **значение**, которое будет использоваться позже.

    ![Свойство OnSelect кнопки "Добавить"](media/working-with-variables/papertape-1.png)

4. Чтобы очистить ленточную ленту, когда пользователь нажмет кнопку **clear** , задайте для свойства **[OnSelect](controls/properties-core.md)** значение этой формулы:

    **Clear( PaperTape )**

    ![Свойство OnSelect кнопки Clear](media/working-with-variables/papertape-2.png)

5. Для отображения нарастающего итога добавьте метку и задайте для нее в качестве значения свойства **[Text](controls/properties-core.md)** следующую формулу:

    **Sum( PaperTape, Value )**

    ![Свойство Text метки](media/working-with-variables/papertape-3.png)

6. Чтобы запустить арифмометр, нажмите F5, чтобы перейти в режим предварительного просмотра, введите число в текстовом поле и нажмите кнопки.

    ![Элемент управления вводом текста отображает значение, а метка показывает промежуточный итог](media/working-with-variables/papertape-run-1.png)

7. Нажмите клавишу ESC, чтобы вернуться в рабочую область по умолчанию.

8. Чтобы отобразить "бумажную ленту", вставьте элемент управления **Таблица данных** и задайте его свойству **[Items](controls/properties-core.md)** следующую формулу:

    **PaperTape**

    В области справа выберите столбец **значение** , чтобы отобразить его.

    ![Таблица данных, в которой отображаются значения, добавленные в коллекцию](media/working-with-variables/papertape-4.png)

9. Чтобы просмотреть значения в коллекции, выберите в меню **Файл** пункт **Коллекции**.

    ![Предварительный просмотр коллекции Папертапе](media/working-with-variables/papertape-file.png)

10. Чтобы сохранить и извлечь коллекцию, добавьте два дополнительных элемента управления "Кнопка" и задайте их свойства **Text** для **загрузки** и **сохранения**. Задайте для свойства **OnSelect** кнопки **Load (загрузить** ) следующую формулу:

     **Clear( PaperTape ); LoadData( PaperTape, "StoredPaperTape", true )**

     Сначала необходимо очистить коллекцию, так как **LoadData** добавит сохраненные значения в конец коллекции.

     ![Свойство OnSelect кнопки Load](media/working-with-variables/papertape-5.png)

11. Задайте для свойства **OnSelect** кнопки **сохранить** следующую формулу:

     **SaveData( PaperTape, "StoredPaperTape" )**

     ![Свойство OnSelect * кнопки "Сохранить"](media/working-with-variables/papertape-6.png)

12. Перейдите в режим предварительного просмотра снова, нажав клавишу F5, введите числа в элементе управления для ввода текста и нажмите кнопки. Нажмите кнопку **Сохранить**. Закройте и перезагрузите приложение и нажмите кнопку " **загрузить** ", чтобы перезагрузить коллекцию.

> [!NOTE]
> Функции **SaveData** и **LoadData** в Power Apps Mobile, но не Power Apps Studio или веб-плеер для Power Apps.