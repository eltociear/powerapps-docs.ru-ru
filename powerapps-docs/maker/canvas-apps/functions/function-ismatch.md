---
title: Функции "Match", "Match" и MatchAll | Документация Майкрософт
description: Справочные сведения, включая синтаксис, для функций IsReference, Match и MatchAll в PowerApps
author: gregli-msft
manager: kvivek
ms.service: powerapps
ms.topic: reference
ms.custom: canvas
ms.reviewer: tapanm
ms.date: 08/15/2019
ms.author: gregli
search.audienceType:
- maker
search.app:
- PowerApps
ms.openlocfilehash: ac6e5196de03a3c2d292696f1216c443f4c5b7e6
ms.sourcegitcommit: 7dae19a44247ef6aad4c718fdc7c68d298b0a1f3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "71992650"
ms.PowerAppsDecimalTransform: true
---
# <a name="ismatch-match-and-matchall-functions-in-powerapps"></a>Функции "Match", "Match" и MatchAll в PowerApps
Проверяет соответствие или извлекает фрагменты текстовой строки на основе шаблона.

## <a name="description"></a>Описание
Функция **IsMatch** проверяет, соответствует ли текстовая строка шаблону, который может содержать обычные символы, предварительно определенные шаблоны или [регулярное выражение](#regular-expressions).  Функции **Match** и **MatchAll** возвращают найденные совпадения, включая подзапросы.  

Используйте **IsMatch**, чтобы проверить, что пользователь ввел в элемент управления **[ввод текста](../controls/control-text-input.md)** . Например, можно проверить, ввел ли пользователь допустимый адрес электронной почты, перед сохранением результата в источник данных. Если запись не соответствует условиям, добавьте другие элементы управления, которые напомнят пользователю, что запись необходимо исправить.

Используйте **Match** для извлечения первой текстовой строки, соответствующей шаблону, и **MatchAll** для извлечения всех текстовых строк, которые совпадают. Кроме того, можно извлечь подзапросы для анализа сложных строк.   

**Match** возвращает запись сведений для первого найденного совпадения, а **MatchAll** возвращает таблицу записей для каждого найденного соответствия. Запись или записи содержат:

| Столбец | Тип | Описание |
|----|----|----|
| *именованное&#8209;подсовпадение&#8209;или подзапросы* | Text | Каждое именованное вложенное соответствие будет иметь свой собственный столбец. Создайте именованное подразделение с помощью **(? &lt;*имя*&gt;** ... **)** в регулярном выражении. Если именованное вложенное совпадение имеет то же имя, что и один из заранее определенных столбцов (см. ниже), то это имеет приоритет, и создается предупреждение. Чтобы избежать этого предупреждения, переименуйте подстроку. |
| **фуллматч** | Text | Вся найденная текстовая строка. |
| **стартматч** | Номер | Начальное расположение совпадения в строке входного текста. Первый символ строки возвращает 1. | 
| **Подстрок соответствия** | Таблица текста с одним столбцом ( **значение**столбца) | Таблица именованных и неименованных подсовпадений в порядке их появления в регулярном выражении. Как правило, именованные подзапросы проще работать с и рекомендуется. Используйте функции [**ForAll**](function-forall.md) или [**Last**](function-first-last.md)( [**FirstN**](function-first-last.md)( **...** )) для работы с отдельным подсовпадением. Если в регулярном выражении не определены подзапросы, эта таблица будет представлена, но пуста. |

Эти функции поддерживают [**матчоптионс**](#match-options). По умолчанию: 
- Эти функции выполняют совпадение с учетом регистра. Используйте **ignoreCase** для выполнения совпадений без учета регистра.    
- **Параметр Match соответствует всей** текстовой строке (**Complete** Матчоптион), а **совпадение** и **MatchAll** Поиск совпадения в любом месте текстовой строки (**содержит** матчоптион). Используйте **полные**, **Contains**, **начинается с**или **endsWith** в соответствии с вашими сценариями.

Если текстовая строка соответствует шаблону, **IsMatch** возвращает значение *true*, в противном случае — *false*. **Match** возвращает *пустое* значение, если совпадение не найдено, которое можно проверить с помощью функции « [**чистым**](function-isblank-isempty.md) ». **MatchAll** возвращает пустую таблицу, если соответствие не найдено, которое можно проверить с помощью функции [**IsEmpty**](function-isblank-isempty.md) .

Если вы используете **MatchAll** для разделения текстовой строки, рассмотрите возможность использования функции **[Split](function-split.md)** , которая более проста в использовании и быстрее.

## <a name="patterns"></a>Шаблоны
Ключом к использованию этих функций является описание шаблона для сопоставления. Опишите шаблон в текстовой строке в виде следующей комбинации:

* Обычные символы, такие как **abc** или **123**.
* Предопределенные шаблоны, такие как **Letter**, **MultipleDigits** или **Email**. (Эти шаблоны определяет перечисление **Match**.)
* Коды регулярных выражений, например **"\d + \s + \d +"** или **"[a-z] +"** .

Объедините эти элементы с помощью [оператора объединения строк **&** ](operators.md). Например, **"abc" & Digit & "\s+"** является допустимым шаблоном, который соответствует символам "a", "b" и "c" с последующей цифрой от 0 до 9, за которой следует по крайней мере один пробел.

### <a name="ordinary-characters"></a>Обычные символы
Самый простой шаблон — это последовательность из обычных символов, которые должны точно совпадать.

Например, при использовании с функцией " **Match** " строка "Hello" точно соответствует шаблону **"Hello"** . И никак иначе. Строка "hello!" не соответствует шаблону из-за восклицательного знака в конце и из-за того, что регистр не подходит для буквы "h". (Способы изменения этого поведения см. в разделе [Параметры поиска совпадения](#match-options).)

В языке шаблона некоторые символы зарезервированы для особых целей. Чтобы использовать эти символы, добавьте перед символом **\\** (обратная косая черта), чтобы указать, что символ должен быть создан буквально, или используйте один из стандартных шаблонов, описанных далее в этом разделе. В следующей таблице перечислены специальные символы.

| Специальный символ | Описание |
| --- | --- |
| **.** |точка |
| **?** |вопросительный знак |
| **&#42;** |звездочка |
| **\+** |плюс |
| **( )** |скобки |
| **[ ]** |квадратные скобки |
| **{ }** |фигурные скобки |
| **^** |знак вставки |
| **$** |знак доллара |
| **\|** |вертикальная черта |
| **\\** |обратная косая черта |

Например, можно сопоставить "Hello?" с помощью шаблона **Hello\\?** с обратной косой чертой перед вопросительным знаком.

### <a name="predefined-patterns"></a>Предопределенные шаблоны
Предопределенные шаблоны предоставляют простой способ сопоставления либо одного из наборов символов, либо последовательности из нескольких символов. Используйте [оператор объединения строк **&** ](operators.md) , чтобы объединить собственные текстовые строки с элементами перечисления **Match** :

| Сопоставить перечисление | Описание | Регулярное выражение |
| --- | --- | --- |
| **Any** |Соответствует любому символу. |`.` |
| **Comma** |Соответствует запятой. |`;` |
| **Digit** |Соответствует числу (от 0 до 9). |`\d` |
| **Email** |Соответствует адресу электронной почты, который содержит символ \@ и имя домена с точкой (".") |`.+\@.+\\.[^\\.]{2;}` |
| **Hyphen** |Соответствует дефису. |`\-` |
| **LeftParen** |Соответствует левой круглой скобке "(". |`\(` |
| **Letter** |Соответствует букве. |`\p{L}` |
| **MultipleDigits** |Соответствует одной или нескольким цифрам. |`\d+` |
| **MultipleLetters** |Соответствует одной или нескольким буквам. |`\p{L}+` |
| **MultipleNonSpaces** |Соответствует одному или нескольким символам, которые не добавляют пробелы (не пробел, знак табуляции или новая строка). |`\S+` |
| **MultipleSpaces** |Соответствует одному или нескольким символам, которые добавляют пробелы (пробел, знак табуляции или символ новой строки). |`\s+` |
| **NonSpace** |Соответствует одному знаку, который не добавляет пробел. |`\S` |
| **OptionalDigits** |Соответствует отсутствующей, одной или нескольким цифрам. |`\d*` |
| **OptionalLetters** |Соответствует отсутствующей, одной или нескольким буквам. |`\p{L}*` |
| **OptionalNonSpaces** |Соответствует отсутствующему, одному или нескольким символам, которые не добавляют пробел. |`\S*` |
| **OptionalSpaces** |Соответствует отсутствующему, одному или нескольким символам, которые добавляют пробел. |`\s*` |
| **Period** |Соответствует точке ("."). |`\.` |
| **RightParen** |Соответствует правой круглой скобке ")". |`\)` |
| **Space** |Соответствует символу, который добавляет пробел. |`\s` |

Например, шаблон **"A" & MultipleDigits** будет соответствовать букве "A", за которой следует одна или несколько цифр.  

### <a name="regular-expressions"></a>Регулярные выражения
Шаблон, используемый этими функциями, является [регулярным выражением](https://en.wikipedia.org/wiki/Regular_expression). Обычные символы и стандартные шаблоны, описанные ранее в этом разделе, помогают создавать регулярные выражения.  

Регулярные выражения очень эффективны и доступны во многих языках программирования для использования в самых разных целях. Они также часто выглядят как случайные последовательности знаков препинания. В этой статье не описаны все аспекты регулярных выражений, но в Интернете доступно множество сведений, руководств и средств.  

Регулярные выражения бывают разными диалектами, а PowerApps использует вариант диалекта JavaScript. Общие сведения о синтаксисе см. в разделе [синтаксис регулярных выражений](https://msdn.microsoft.com/library/1400241x.aspx) . Поддерживаются именованные подзапросы (иногда называемые именованными группами захвата):

- Именованные подвыражения: **(? &lt;*имя*&gt;...)**
- Именованные обратные ссылки  **\\k&lt;*имя*&gt;**

В таблице Enum **Match** , приведенной выше в этом разделе, каждое перечисление отображается в той же строке, что и соответствующее регулярное выражение.

## <a name="match-options"></a>Параметры сопоставления
Поведение этих функций можно изменить, указав один или несколько параметров, которые можно комбинировать с помощью оператора сцепления строк ( **&amp;** ).  

| Перечисление Матчоптионс | Описание | Влияние на регулярное выражение |
| --- | --- | --- |
| **BeginsWith** |Шаблон должен совпадать с самого начала текста. |Добавляет **^** в начало регулярного выражения. |
| **Complete** |По умолчанию для **Match**. Шаблон должен соответствовать всей строке текста от начала до конца. |Добавляет **^** в начало и **$** в конец регулярного выражения. |
| **Contains** |По умолчанию для **Match** и **MatchAll**. Шаблон должен присутствовать где-нибудь в тексте, но не обязательно в начале или в конце. |Не изменяет регулярного выражения. |
| **EndsWith** |Шаблон должен соответствовать концу строки текста. |Добавляет **$** в конец регулярного выражения. |
| **IgnoreCase** |Обрабатывает буквы в верхнем и нижнем регистре как идентичные. По умолчанию при поиске совпадения учитывается регистр. |Не изменяет регулярного выражения. Этот параметр эквивалентен стандартному модификатору "i" для регулярных выражений.  |
| **Multiline** |Выполняет сопоставление по нескольким строкам. |Не изменяет регулярного выражения. Этот параметр эквивалентен стандартному модификатору m для регулярных выражений. |

Использование **MatchAll** эквивалентно использованию стандартного модификатора "g" для регулярных выражений.

## <a name="syntax"></a>Синтаксис
**IsMatch**( *текст*; *шаблон* [; *параметры* ] )

* *Текст* — требуется. Текстовая строка для проверки.
* *Шаблон* — требуется. Шаблон для проверки в виде текстовой строки. Объединение предопределенных шаблонов, определяемых перечислением **соответствия** , или предоставление регулярного выражения. *Шаблон* должен быть константной формулой без каких-либо переменных, источников данных или других динамических ссылок, которые изменяются при запуске приложения.
* *Параметры* — необязательно. Сочетание строк текста, состоящее из значений перечисления **матчоптионс** . По умолчанию используется **MatchOptions.Complete**.

**Match**( *текст*; *шаблон* [; *Параметры* ])

* *текст* — обязательный аргумент. Текстовая строка для сопоставления.
* *Шаблон* — требуется. Шаблон для сопоставления в виде текстовой строки. Объединение предопределенных шаблонов, определяемых перечислением **соответствия** , или предоставление регулярного выражения. *Шаблон* должен быть константной формулой без каких-либо переменных, источников данных или других динамических ссылок, которые изменяются при запуске приложения.
* *Параметры* — необязательно. Сочетание строк текста, состоящее из значений перечисления **матчоптионс** . По умолчанию используется **матчоптионс. Contains** .

**MatchAll**( *текст*; *шаблон* [; *Параметры* ])

* *текст* — обязательный аргумент. Текстовая строка для сопоставления.
* *Шаблон* — требуется. Шаблон для сопоставления в виде текстовой строки. Объединение предопределенных шаблонов, определяемых перечислением **соответствия** , или предоставление регулярного выражения. *Шаблон* должен быть константной формулой без каких-либо переменных, источников данных или других динамических ссылок, которые изменяются при запуске приложения.
* *Параметры* — необязательно. Сочетание строк текста, состоящее из значений перечисления **матчоптионс** . По умолчанию используется **матчоптионс. Contains** .

## <a name="ismatch-examples"></a>Примеры подстрок
### <a name="ordinary-characters"></a>Обычные символы
Представьте, что приложение содержит элемент управления **ввода текста** с именем **TextInput1**. Пользователь вводит значения в этот элемент управления для сохранения в базе данных.   

Пользователь вводит в элемент **TextInput1** **Hello world**.

| Формула | Описание | Возвращаемый результат |
| --- | --- | --- |
| `IsMatch( TextInput1.Text; "Hello world" )` |Проверяет, совпадают ли введенные пользователем данные в точности со строкой "Hello World". |**true** |
| `IsMatch( TextInput1.Text; "Good bye" )` |Проверяет, совпадают ли введенные пользователем данные в точности со строкой "Good Bye". |**false** |
| `IsMatch( TextInput1.Text; "hello"; Contains )` |Проверяет, содержит ли вводимые пользователем данные слово "Hello" (с учетом регистра). |**false** |
| `IsMatch( TextInput1.Text; "hello"; Contains & IgnoreCase )` |Проверяет, содержат ли введенные данные слово "hello" (без учета регистра). |**true** |

### <a name="predefined-patterns"></a>Предопределенные шаблоны

|                                                            Формула                                                            |                                                                Описание                                                                |  Возвращаемый результат   |
|-------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| `IsMatch( "123-45-7890"; Digit & Digit & Digit & Hyphen & Digit & Digit & Hyphen & Digit & Digit & Digit & Digit )` |                                              Соответствует номеру социального страхования США.                                               | **true**  |
|                                           `IsMatch( "joan@contoso.com"; Email )`                                            |                                                         Соответствует адресу электронной почты.                                                          | **true**  |
|                              `IsMatch( "123.456"; MultipleDigits & Period & OptionalDigits )`                               |                                   Соответствует последовательности цифр, за которыми следует точка, а затем отсутствующая цифра или другие цифры.                                   | **true**  |
|                                `IsMatch( "123"; MultipleDigits & Period & OptionalDigits )`                                 | Соответствует последовательности цифр, за которыми следует точка, а затем отсутствующая цифра или другие цифры. Точка не отображается в тексте для сопоставления, поэтому этот шаблон не соответствует. | **false** |

### <a name="regular-expressions"></a>Регулярные выражения

|                                                                              Формула                                                                              |                                                                                                                                  Описание                                                                                                                                   |  Возвращаемый результат   |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|
|                                                                    `IsMatch( "986"; "\d+" )`                                                                   |                                                                                                                    Соответствует целочисленному значению больше нуля.                                                                                                                     | **true**  |
|                                                               `IsMatch( "1.02"; "\d+(\.\d\d)?" )`                                                              |                                        Обозначает положительную денежную сумму. Если входные данные содержат десятичную запятую, входные данные должны также содержать два цифровых символа после десятичной запятой. Например, 3.00 является допустимым значением, а 3.1 — нет.                                         | **true**  |
|                                                            `IsMatch( "-4.95"; "(-)?\d+(\.\d\d)?" )`                                                             |                                                        Обозначает положительную или отрицательную денежную сумму. Если входные данные содержат десятичную запятую, входные данные должны также содержать два цифровых символа после десятичной запятой.                                                        | **true**  |
|                                                         `IsMatch( "111-11-1111"; "\d{3}-\d{2}-\d{4}" )`                                                        | Соответствует номеру социального страхования США. Проверяет формат, тип и длину указанного поля ввода. Строка для сопоставления должна состоять из трех числовых символов, за которыми следует тире, затем два числовых символа, за которыми следует тире, а затем четыре числовых символа. | **true**  |
|                                                         `IsMatch( "111-111-111"; "\d{3}-\d{2}-\d{4}" )`                                                         |                                                                                               Аналогично предыдущему примеру, но во входных данных отсутствует один из дефисов.                                                                                               | **false** |
|                                         `IsMatch( "AStrongPasswordNot"; "(?!^[0-9]\*$)(?!^[a-zA-Z]\*$)([a-zA-Z0-9]{8,10})" )`                                        |                                        Проверяет надежный пароль, который должен содержать восемь, девять или 10 символов, в дополнение к одной цифре и по крайней мере один алфавитный символ. Строка не должна содержать специальные символы.                                        | **false** |
| `IsMatch( "<https://microsoft.com>"; "(ht&#124;f)tp(s?)\:\/\/\[0-9a-zA-Z\]([-.\w]\*[0-9a-zA-Z])\*(:(0-9)\*)\*(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&%\$#_]\*)?" )` |                                                                                                                     Проверяет URL-адрес HTTP, HTTPS или FTP.                                                                                                                      | **true**  |

## <a name="match-and-matchall-examples"></a>Примеры Match и MatchAll

| Формула | Описание | Возвращаемый результат |
|--------|------------|-----------|
| `Match( "Bob Jones <bob.jones@contoso.com>"; "<(?<email>" & Match.Email & ")>"` | Извлекает только часть электронной почты контактной информации.  | {<br>адрес электронной почты: &nbsp; "bob.jones@contoso.com",<br>Фуллматч: &nbsp; "&lt; @ no__t-2 >",<br>Подсовпадений: &nbsp; [&nbsp; "bob.jones@contoso.com" &nbsp;],<br>Стартматч: стр<br>}  
| `Match( "Bob Jones <InvalidEmailAddress>"; "<(?<email>" & Match.Email & ")>"` | Извлекает только часть электронной почты контактной информации. Юридический адрес не найден (отсутствует знак @), поэтому функция возвращает *пустое*значение. | *пустое значение* |  
| `Match( Language(); "(<language>\w{2})(?:-(?<script>\w{4}))?(?:-(?<region>\w{2}))?" )` | Извлекает фрагменты языка, скрипта и региона тега Language, возвращаемого **[языковой](function-language.md)** функцией. Эти результаты соответствуют США; Дополнительные примеры см. в [документации по функции **языка** ](function-language.md) .  Оператор **(?:** ) группирует символы без создания другого подвыражения. | {<br>Language: EN,<br>Скрипт: *пусто*, <br>регионе "US",<br>Фуллматч: "en-US", <br>Подсовпадений: ["en", "", "US"], <br>Стартматч: 1<br>} 
| `Match( "PT2H1M39S"; "PT(?:<hours>\d+)H)?(?:(?<minutes>\d+)M)?(?:(?<seconds>\d+)S)?" )` | Извлекает часы, минуты и секунды из значения длительности ISO 8601. Извлеченные числа по-прежнему находятся в текстовой строке; Используйте функцию [**value**](function-value.md) , чтобы преобразовать ее в число до выполнения математических операций над ним.  | {<br> суток "2",<br>тезис "1",<br>несколько "39",<br>Фуллматч: "PT2H1M39S",<br>Подсовпадений: &nbsp; [&nbsp; "2", &nbsp; "1", &nbsp; "39" &nbsp;],<br>Стартматч: 1<br>} |

Давайте подробно рассмотрим последний пример. Если вы хотите преобразовать эту строку в значение даты и времени с помощью функции **[time](function-date-time.md)** , необходимо передать именованные подзапросы по отдельности. Для этого можно использовать функцию **[with](function-with.md)** **, которая работает** с записью, которая возвращает:

``` powerapps-comma
With( 
    Match( "PT2H1M39S"; "PT(?:(?<hours>\d+)H)?(?:(?<minutes>\d+)M)?(?:(?<seconds>\d+)S)?" ); 
    Time( Value( hours ); Value( minutes ); Value( seconds ) )
)
```

Для этих примеров добавьте элемент управления « [кнопка](../controls/control-button.md) », задайте для него свойство **OnSelect** , а затем нажмите кнопку:

``` powerapps-comma
Set( pangram; "The quick brown fox jumps over the lazy dog." )
```
 
| Формула | Описание | Возвращаемый результат |
|---------|-------------|--------|
| `Match( pangram; "THE"; IgnoreCase )` | Найти все совпадения "The" в текстовой строке, содержащейся в переменной **панграм** . Строка содержит два совпадения, но возвращается только первый, так как вы используете **Match** и Not **MatchAll**. Столбец подсовпаденией пуст, так как не были определены подзапросы.  | {<br>Фуллматч: "The",<br>Подсовпадений: [&nbsp;],<br>Стартматч: 32<br>} |
| `MatchAll( pangram; "the" )` | Найти все совпадения "The" в текстовой строке, содержащейся в переменной **панграм** . Тест учитывает регистр, поэтому найден только второй экземпляр "The". Столбец подсовпаденией пуст, так как не были определены подзапросы.  | <style> img { max-width: none } </style> ![](media/function-ismatch/pangram-the-one.png) |
| `MatchAll( pangram; "the"; IgnoreCase )` | Найти все совпадения "The" в текстовой строке, содержащейся в переменной **панграм** . В этом случае тест учитывает регистр, поэтому обнаруживаются оба экземпляра слова. Столбец подсовпаденией пуст, так как не были определены подзапросы.  | <style> img { max-width: none } </style> ![](media/function-ismatch/pangram-the-two.png) |
| `MatchAll( pangram; "\b\wo\w\b" )` | Находит все три буквы с символом "o" в середине. Обратите внимание, что "Браун" исключен из-за того, что не является буквенно-трехзначный буквой и, следовательно, не соответствует "\b" (граница слова).  | <style> img { max-width: none } </style> ![](media/function-ismatch/pangram-fox-dog.png) |
| `Match( pangram; "\b\wo\w\b\s\*(?<between>\w.+\w)\s\*\b\wo\w\b" )` | Соответствует всем символам между "Fox" и "Dog". | {<br>между: &nbsp; "переходитs @ no__t-1Over @ no__t-2the @ no__t-3lazy".<br>Фуллматч: &nbsp; "Fox @ no__t-1jumps @ no__t-2over @ no__t-3the @ no__t-4lazy @ no__t-5dog",<br>Подсовпадений: ["переходит на отложенную"],<br>Стартматч: широкоэкранны<br> } |

Чтобы просмотреть результаты **MatchAll** в коллекции, сделайте следующее:

1. На пустом экране Вставьте пустой вертикальный элемент управления " **[коллекция](../controls/control-gallery.md)** ".

2. Задайте для свойства **Items** коллекции значение **MatchAll (панграм, "\w +")** или **MatchAll (панграм, мултиплелеттерс)** .

    ![](media/function-ismatch/pangram-gallery1.png)

3. Выберите "добавить элемент на вкладке" Вставка "в середине элемента управления" Коллекция ", чтобы выбрать шаблон коллекции. 

5. Добавьте элемент управления **[Label](../controls/control-text-box.md)** в шаблон коллекции.  

4. Присвойте свойству **Text** метки значение **сиситем. фуллматч**.  
 
    Коллекция заполняется каждым словом в нашем примере текста.  Измените размер шаблона коллекции и элемента управления "метка", чтобы увидеть все слова на одном экране.

    ![](media/function-ismatch/pangram-gallery2.png)
